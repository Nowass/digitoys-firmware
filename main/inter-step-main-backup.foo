#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "esp_log.h"
#include "esp_system.h"
#include "driver/rmt_tx.h"
#include "driver/rmt_rx.h"
#include "driver/gpio.h"
#include <rtc.h>
#include "esp_task_wdt.h"

static const char *TAG = "RMT_PWM";

// GPIO pins
constexpr gpio_num_t PWM_GEN_GPIO = GPIO_NUM_6;         // Bit-bang generator (test only)
constexpr gpio_num_t PWM_INPUT_GPIO = GPIO_NUM_7;       // RMT RX input
constexpr gpio_num_t PWM_PASSTHROUGH_GPIO = GPIO_NUM_8; // RMT TX passthrough

// Timing
constexpr uint32_t RMT_CLK_HZ = 1'000'000;     // 1 µs tick
constexpr uint32_t RMT_PWM_PERIOD_US = 20'000; // 20 ms period

// RMT handles + queue
static rmt_channel_handle_t rx_chan = nullptr;
static rmt_channel_handle_t tx_pt_chan = nullptr;
static rmt_encoder_handle_t encoder_pt = nullptr;
static QueueHandle_t pass_queue = nullptr;

// Shared TX config
static const rmt_transmit_config_t tx_config = {
    .loop_count = 0,
    .flags = {.eot_level = 0}};

// RX config + buffer
static rmt_receive_config_t rx_config;
static rmt_symbol_word_t rx_buf[8];

// RX ISR callback: enqueue first symbol, re-arm receive
static bool IRAM_ATTR on_rmt_rx_done(
    rmt_channel_handle_t channel,
    const rmt_rx_done_event_data_t *edata,
    void *user_data)
{
    if (edata->num_symbols > 0)
    {
        BaseType_t w = pdFALSE;
        xQueueSendFromISR(pass_queue,
                          &edata->received_symbols[0],
                          &w);
        if (w)
            portYIELD_FROM_ISR();
    }
    // restart RMT receive
    rmt_receive(rx_chan, rx_buf, sizeof(rx_buf), &rx_config);
    return false;
}

// Initialize RMT RX + callback
void init_rmt_rx()
{
    rmt_rx_channel_config_t cfg = {};
    cfg.gpio_num = PWM_INPUT_GPIO;
    cfg.clk_src = RMT_CLK_SRC_DEFAULT;
    cfg.resolution_hz = RMT_CLK_HZ;
    cfg.mem_block_symbols = 64;
    cfg.intr_priority = 1;
    cfg.flags.invert_in = false;
    cfg.flags.with_dma = false;
    cfg.flags.allow_pd = false;

    ESP_ERROR_CHECK(rmt_new_rx_channel(&cfg, &rx_chan));
    ESP_ERROR_CHECK(rmt_enable(rx_chan));

    rx_config.signal_range_min_ns = 1000;                     // filter <1 µs
    rx_config.signal_range_max_ns = RMT_PWM_PERIOD_US * 1000; // idle >20 ms
    rx_config.flags.en_partial_rx = true;

    static rmt_rx_event_callbacks_t cbs = {.on_recv_done = on_rmt_rx_done};
    ESP_ERROR_CHECK(rmt_rx_register_event_callbacks(rx_chan, &cbs, nullptr));
    ESP_ERROR_CHECK(rmt_receive(rx_chan, rx_buf, sizeof(rx_buf), &rx_config));
}

// Initialize RMT TX for passthrough (GPIO8)
void init_rmt_tx_passthrough()
{
    rmt_tx_channel_config_t cfg = {};
    cfg.gpio_num = PWM_PASSTHROUGH_GPIO;
    cfg.clk_src = RMT_CLK_SRC_DEFAULT;
    cfg.resolution_hz = RMT_CLK_HZ;
    cfg.mem_block_symbols = 64;
    cfg.trans_queue_depth = 8;
    cfg.flags.invert_out = false;

    ESP_ERROR_CHECK(rmt_new_tx_channel(&cfg, &tx_pt_chan));
    ESP_ERROR_CHECK(rmt_enable(tx_pt_chan));

    rmt_copy_encoder_config_t ecfg = {};
    ESP_ERROR_CHECK(rmt_new_copy_encoder(&ecfg, &encoder_pt));
}

// GPIO6 bit-bang PWM generator (test only)
void gen_task(void *)
{
    // Register this task with the Task-WDT
    esp_task_wdt_add(NULL);
    const uint32_t high_us = (RMT_PWM_PERIOD_US * 20) / 100;      // 4 ms
    const uint32_t low_ms = (RMT_PWM_PERIOD_US - high_us) / 1000; // 16 ms
    gpio_reset_pin(PWM_GEN_GPIO);
    gpio_set_direction(PWM_GEN_GPIO, GPIO_MODE_OUTPUT);
    gpio_set_level(PWM_GEN_GPIO, 0);

    while (true)
    {
        // Feed the WDT
        esp_task_wdt_reset();
        gpio_set_level(PWM_GEN_GPIO, 1);
        esp_rom_delay_us(high_us); // <--- updated here
        gpio_set_level(PWM_GEN_GPIO, 0);
        vTaskDelay(pdMS_TO_TICKS(low_ms));
    }
}

// Passthrough task: dequeue symbol + RMT-TX on GPIO8
void pt_task(void *)
{
    // Register this task with the Task-WDT
    esp_task_wdt_add(NULL);
    rmt_symbol_word_t sym;
    while (true)
    {
        // Feed the WDT
        esp_task_wdt_reset();
        xQueueReceive(pass_queue, &sym, portMAX_DELAY);
        rmt_encoder_reset(encoder_pt);
        ESP_ERROR_CHECK(rmt_transmit(
            tx_pt_chan,
            encoder_pt,
            &sym,
            sizeof(sym),
            &tx_config));
        ESP_ERROR_CHECK(rmt_tx_wait_all_done(
            tx_pt_chan,
            portMAX_DELAY));
    }
}

extern "C" void app_main()
{
    // 10-second Task-WDT timeout, panic on expiry
    // esp_task_wdt_config_t wdt_cfg = {
    //     .timeout_ms = 10000,        // 10 seconds
    //     .idle_core_mask = (1 << 0), // watch CPU0 idle task too
    //     .trigger_panic = true       // panic & reboot on timeout
    // };
    // ESP_ERROR_CHECK(esp_task_wdt_init(&wdt_cfg));
    // Create ISR->task queue
    pass_queue = xQueueCreate(8, sizeof(rmt_symbol_word_t));
    assert(pass_queue);

    // Hybrid init
    init_rmt_rx();
    init_rmt_tx_passthrough();

    // Start generator and passthrough
    xTaskCreate(gen_task, "gen", 2048, NULL, 4, NULL);
    xTaskCreate(pt_task, "pt", 2048, NULL, 5, NULL);
}
